팀프로젝트를 하던 도중 내 컴포넌트에서 가져와야 할 데이터와 다른 페이지에서 사용한 데이터가 겹쳤다. 그래서 팀원분이 만들어 놓으신 zustand store에서 가져다 쓰는 것으로 리팩토링을 하려고 했다. 이에 튜터님이 왜 react-query를 안쓰고 zustand를 쓰냐고 여쭤보셨는데 대답을 하지 못했다.

react-query, zustand 그리고 redux까지 react 상태관리 라이브러리가 너무 많아서 언제 어떤걸 쓰고 각자의 장단점이 무엇인지 헷갈렸는데 이번 기회에 정리를 해봐야겠다.

# 먼저, 상태관리를 왜 해야할까?

### **1. 단방향 바인딩**

- 리액트는 단방향 바인딩을 지원하기 때문

부모 → 자식은 가능하지만

자식 → 부모는 불가능하다,,, (물려받기만 가능)

자식에서 부모의 상태를 바꾸려면 setState를 props로 자식에게 전달해야 한다.

### **2. props drilling**

- 할머니 → 엄마 → 딸

할머니의 상태값을 엄마는 사용하지 않는데 딸만 사용한다면 그래도 엄마에게 전달을 해줘야 한다.

만약 이런 형태의 컴포넌트가 계속 깊어지고 많아진다면 ⇒ props drilling

### **3.** context API

그래서 나온 context API

- A마을 사람들이 공통적으로 사용하는 state는 A마을 꼭대기에서 공유

데이터가 필요한 컴포넌트에서만 가져다 쓸 수 있다는 장점이 있다.

하지만 **동일한 Provider 하위에서 context를 구독하는 모든 컴포넌트는 Provider의 value prop이 바뀔 때마다 모두 리렌더링된다는 단점이 있다.**

위 문제를 해결하기 위해 memo를 사용할 수도 있지만, 부모 컴포넌트가 memo를 사용했다 하더라도 그 자식이 context를 참조한다면 그 자식의 자식 컴포넌트도 리렌더링이 된다.

어쨌거나 불필요한 리렌더링은 피할 수 없고, memo를 적절히 활용할 수 밖에 없는 상황에 처해지게 된다.

그리고 근본적으로 Context API는 상태 관리 도구가 아니다!!!

---

## **상태 관리란?**

- 다음 세 가지 역할을 수행해야 한다.
  - 초기값 저장
  - 현재값 읽기
  - 값 업데이트
- 리액트의 useState와 useReducer 훅을 활용하는 것은? 상태 관리

→ 훅을 호출해서 초기값을 저장하고,state로 현재값을 읽고,setState 또는 dispatch로 값을 업데이트한다.

**Context는 만들어진 상태를 단순히 전달할 뿐, 실질적으로 상태를 관리하는 것은 useState와 useReducer 훅인 것이다.**

---

### 1. Redux

- Redux 자체만으로 상태를 관리할 수 있다.

- 스토어의 특정 값이 변화하더라도 해당 값만 구독하고 있는 컴포넌트만 리렌더링이 발생한다.

- **하지만 거대한 보일러 플레이트를 작성**

### 2. zustand

**Zustand는 Redux처럼 Flux를 사용하는 친구다.**

차이점이라면,

**SSR을 공식적으로 지원한다.Redux보다 더 간단하고 직관적인 훅 기반의 API를 제공한다.Provider로 감싸지 않아도 된다.**

자, 여기까지가 전역상태관리 즉 **클라이언트 상태 관리** 라이브러리였다.

<aside>
💡 Client-State : 세션간 지속적이지 않는 데이터, 동기적, 클라이언트가 소유, 항상 최신 데이터로 업데이트
(렌더링에 반영) Ex. 리액트 컴포넌트의 state, 동기적으로 저장되는 redux store의 데이터

</aside>

---

<aside>
💡 Server-State : 세션간 지속되는 데이터, 비동기적, 세션을 진행하는 클라이언트만 소유하는게 아니고 공유되는 데이터도 존재하며 여러 클라이언트에 의해 수정될 수 있음.
클라이언트는 서버 데이터의 스냅샷만을 사용하기 때문에 클라이언트에서 보이는 서버 데이터는 항상 최신임을 보장할 수 없음
Ex. 백엔드 DB에 저장되어있는 데이터

</aside>

---

### 3. React-Query

리액트 쿼리는 **서버 상태 관리** 라이브러리다!!

1. 캐싱, 리패칭을 알아서 해준다.

- 캐싱 : 자주 사용하는 데이터의 복사본을 저장한다 (앱 처리 속도를 높여줌)
- 리패칭 : 데이터를 다시 가져온다.(최신 데이터를 참조할 수 있게 알아서 보장)
- 불필요한 네트워크 통신을 줄일 수 있다!

2. Context API 제공
3. useQuery를 통해 만들어진 query는 고유한 key로 구분되어 여러개의 query를 컴포넌트 곳곳에다가 흩뿌려 놓아도 key만 같으면 동일한 query에 접근할 수 있다(비동기 관련 성공, 실패 액션 하나하나를 모두 선언할 필요가 없음)
4. 선언적으로 프로그래밍이 가능하다.

<br>
즉, 나의 경우 서버 상태를 관리해야 하기 때문에 zustand가 아닌 react-query를 사용하는 것이 맞았다.
<br>
query-key가 같다면 같은 코드라도 한 번 요청하기 때문에 선후관계가 필요 없다.
